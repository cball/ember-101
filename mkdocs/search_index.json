{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Ember-CLI 101 workshop hosted by \nSan Diego Ember\n.\n\n\nPre-event setup instructions\n\n\n\n\nInstall Git\n\n\nInstall Node.js\n\n\nSetup NPM for non-sudo installation\n\n\nThe easiest way to do this is by checking out \nthis awesome shell script\n that will do it for you\n\n\nNPM is the node package manager. It will automatically be installed when you install node.\n\n\nNPM installs packages locally (within the directory it is invoked in) for per-project modules, or globally for packages you want accessible everywhere.\n\n\nHowever, by default NPM installs global packages in a root-restricted location, requiring SUDO to install. This creates a huge headache. As an alternative, before you install any packages, follow \nthis guide\n to configure your NPM to install in your home directory without requiring sudo.\n\n\n\n\n\n\nInstall \nBower\n: \nnpm i -g bower\n\n\nInstall \nEmber-CLI\n: \nnpm i -g ember-cli\n\n\nAnd create a new project named 'workshop': \nember new workshop\n\n\nChange directories into workshop: \ncd workshop\n and install your local dependencies with: \nember install\n\n\n\n\nGoal: reduce the glue\n\n\nWeb application development can involve a lot of repetition.  Attempts to reduce the repetition involved in web development has given rise to a variety of scaffolding tools and best practices.  These scaffolding tools are all trying to do the same thing:  reduce the amount of work necessary to \"get started\" by providing a set of \"best practices\" that are enabled default.  These choices include things like:\n\n\n\n\nApplication directory structure\n\n\nGenerators for common components\n\n\nModularity choices (AMD/node modules/etc)\n\n\nBuild system\n\n\nAsset compilation \n minification\n\n\nTesting framework and setup\n\n\n\n\nEmber-CLI\n\n\nEmber-CLI\n provides choices for all of the aforementioned areas.  We'll dive into some of these choices in more detail later but at a high level Ember-CLI builds in:\n\n\n\n\nA directory structure which we'll explore more later\n\n\nGenerators for all common components\n\n\nES6 modules transpiled to AMD\n\n\nBroccoli build tool for builds. (Fast and extensible with plugin architecture\n\n\nAsset minification also via Broccoli\n\n\nQUnit for testing\n\n\n\n\nModules\n\n\nModules allow you to divide logical portions of code into smaller, functional pieces and include them as needed. As your application grows, smaller pieces of functional code become easier to manage, support, maintain and test. To learn more about JS Modules, check out \njsmodules.io\n\n\nBest practices\n\n\n\n\nCode\n\n\nTitleCase\n naming of classes\n\n\ncamelCase\n naming of attributes\n\n\nuse modules, avoid globals\n\n\nreusable code \u2192 components, mixins, extend, add-ons\n\n\n\n\n\n\nFiles\n\n\nkebab-case-naming.js\n\n\nchildren in subdirectory \u2192 \nroutes/invoices/edit.js\n \n \nroutes/invoices/new.js", 
            "title": "Home"
        }, 
        {
            "location": "/#pre-event-setup-instructions", 
            "text": "Install Git  Install Node.js  Setup NPM for non-sudo installation  The easiest way to do this is by checking out  this awesome shell script  that will do it for you  NPM is the node package manager. It will automatically be installed when you install node.  NPM installs packages locally (within the directory it is invoked in) for per-project modules, or globally for packages you want accessible everywhere.  However, by default NPM installs global packages in a root-restricted location, requiring SUDO to install. This creates a huge headache. As an alternative, before you install any packages, follow  this guide  to configure your NPM to install in your home directory without requiring sudo.    Install  Bower :  npm i -g bower  Install  Ember-CLI :  npm i -g ember-cli  And create a new project named 'workshop':  ember new workshop  Change directories into workshop:  cd workshop  and install your local dependencies with:  ember install", 
            "title": "Pre-event setup instructions"
        }, 
        {
            "location": "/#goal-reduce-the-glue", 
            "text": "Web application development can involve a lot of repetition.  Attempts to reduce the repetition involved in web development has given rise to a variety of scaffolding tools and best practices.  These scaffolding tools are all trying to do the same thing:  reduce the amount of work necessary to \"get started\" by providing a set of \"best practices\" that are enabled default.  These choices include things like:   Application directory structure  Generators for common components  Modularity choices (AMD/node modules/etc)  Build system  Asset compilation   minification  Testing framework and setup", 
            "title": "Goal: reduce the glue"
        }, 
        {
            "location": "/#ember-cli", 
            "text": "Ember-CLI  provides choices for all of the aforementioned areas.  We'll dive into some of these choices in more detail later but at a high level Ember-CLI builds in:   A directory structure which we'll explore more later  Generators for all common components  ES6 modules transpiled to AMD  Broccoli build tool for builds. (Fast and extensible with plugin architecture  Asset minification also via Broccoli  QUnit for testing", 
            "title": "Ember-CLI"
        }, 
        {
            "location": "/#modules", 
            "text": "Modules allow you to divide logical portions of code into smaller, functional pieces and include them as needed. As your application grows, smaller pieces of functional code become easier to manage, support, maintain and test. To learn more about JS Modules, check out  jsmodules.io", 
            "title": "Modules"
        }, 
        {
            "location": "/#best-practices", 
            "text": "Code  TitleCase  naming of classes  camelCase  naming of attributes  use modules, avoid globals  reusable code \u2192 components, mixins, extend, add-ons    Files  kebab-case-naming.js  children in subdirectory \u2192  routes/invoices/edit.js     routes/invoices/new.js", 
            "title": "Best practices"
        }, 
        {
            "location": "/understanding-basics/", 
            "text": "Project Organization: High level\n\n\nIn the \nPre-event setup instructions\n section you generated a new ember project called \nworkshop\n. Let's step inside and start exploring:\n\n\n$ cd workshop\n$ ls -A\napp               .bowerrc     dist           .git        node_modules  README.md    tmp\nbower_components  Brocfile.js  .editorconfig  .gitignore  package.json  testem.json  .travis.yml\nbower.json        config       .ember-cli     .jshintrc   public        tests        vendor\n\n\n\n\nnode modules\n\n\nThe first things to notice is the file \npackage.json\n and the directory \nnode_modules\n. These are from NPM, and if you're new to NPM, take a look at what is in the \npackage.json\n file.  This file contains information about what NPM modules are required to run and develop our app. You'll see that the packages needed for broccoli and Ember-CLI are specified here. When using Ember-CLI you won't often edit this directly. If you were to install any Ember-CLI addons yourself, you would see them show up in here as well. The packages specified in \npackage.json\n will be installed in the \nnode_modules\n directory.\n\n\nbower components\n\n\nThe next thing to look at is the file \nbower.json\n and the \nbower_components\n directory. These are similar to \npackage.json\n and \nnode_modules\n. Bower has become the de facto standard for front-end package management and our Ember-CLI application will use it to manage many of our dependencies. If you open up \nbower.json\n you'll see that our application comes out of the box with not only Ember but jQuery, Ember Data (for data persistence), and QUnit (for testing).\n\n\ntests\n\n\nEmber-CLI comes out-of-the box with a testing framework and provides some helpers to make testing easier. You can test models, routes, controllers and components, and you can test user flows.\n\n\nUnit tests allow us to focus on specific functionality of a module and do not require the entire Ember application be running. Acceptance tests, also called integration tests, are used to test the flow of your app. They emulate user interactions throughout your application and using helpers you can make assertions about the expected functionality.\n\n\npublic and vendor\n\n\nYou may be wondering where images, fonts and other miscellaneous asset files should go. The answer is the \npublic\n directory. These will be served at the root of your application.\n\n\nSimilarly, you may have JavaScript or CSS dependencies that are not in bower. These can be stored in the \nvendor\n directory. Loading vendor files is not something we will cover in this workshop.\n\n\nThe 'app' directory\n\n\nThe app directory is where we're going to put all of our own code.  It is carefully structured with an appropriate place for each type of module:\n\n\n$ ls app\napp.js          controllers     index.html      router.js       styles          views\ncomponents      helpers         models          routes          templates\n\n\n\n\nSome of these may sound familiar to you, while others may be brand new.  Don't worry yet if you don't know what all of these different pieces are.  We'll get to them one by one.", 
            "title": "Understanding Basics"
        }, 
        {
            "location": "/understanding-basics/#project-organization-high-level", 
            "text": "In the  Pre-event setup instructions  section you generated a new ember project called  workshop . Let's step inside and start exploring:  $ cd workshop\n$ ls -A\napp               .bowerrc     dist           .git        node_modules  README.md    tmp\nbower_components  Brocfile.js  .editorconfig  .gitignore  package.json  testem.json  .travis.yml\nbower.json        config       .ember-cli     .jshintrc   public        tests        vendor", 
            "title": "Project Organization: High level"
        }, 
        {
            "location": "/understanding-basics/#node-modules", 
            "text": "The first things to notice is the file  package.json  and the directory  node_modules . These are from NPM, and if you're new to NPM, take a look at what is in the  package.json  file.  This file contains information about what NPM modules are required to run and develop our app. You'll see that the packages needed for broccoli and Ember-CLI are specified here. When using Ember-CLI you won't often edit this directly. If you were to install any Ember-CLI addons yourself, you would see them show up in here as well. The packages specified in  package.json  will be installed in the  node_modules  directory.", 
            "title": "node modules"
        }, 
        {
            "location": "/understanding-basics/#bower-components", 
            "text": "The next thing to look at is the file  bower.json  and the  bower_components  directory. These are similar to  package.json  and  node_modules . Bower has become the de facto standard for front-end package management and our Ember-CLI application will use it to manage many of our dependencies. If you open up  bower.json  you'll see that our application comes out of the box with not only Ember but jQuery, Ember Data (for data persistence), and QUnit (for testing).", 
            "title": "bower components"
        }, 
        {
            "location": "/understanding-basics/#tests", 
            "text": "Ember-CLI comes out-of-the box with a testing framework and provides some helpers to make testing easier. You can test models, routes, controllers and components, and you can test user flows.  Unit tests allow us to focus on specific functionality of a module and do not require the entire Ember application be running. Acceptance tests, also called integration tests, are used to test the flow of your app. They emulate user interactions throughout your application and using helpers you can make assertions about the expected functionality.", 
            "title": "tests"
        }, 
        {
            "location": "/understanding-basics/#public-and-vendor", 
            "text": "You may be wondering where images, fonts and other miscellaneous asset files should go. The answer is the  public  directory. These will be served at the root of your application.  Similarly, you may have JavaScript or CSS dependencies that are not in bower. These can be stored in the  vendor  directory. Loading vendor files is not something we will cover in this workshop.", 
            "title": "public and vendor"
        }, 
        {
            "location": "/understanding-basics/#the-app-directory", 
            "text": "The app directory is where we're going to put all of our own code.  It is carefully structured with an appropriate place for each type of module:  $ ls app\napp.js          controllers     index.html      router.js       styles          views\ncomponents      helpers         models          routes          templates  Some of these may sound familiar to you, while others may be brand new.  Don't worry yet if you don't know what all of these different pieces are.  We'll get to them one by one.", 
            "title": "The 'app' directory"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Ready to code!\n\n\n\n\nember install\n (if you didn't do this before)\n\n\nember serve\n\n\nhttp://localhost:4200\n\n\n\n\nInstall Bootstrap\n\n\nLet's use Bootstrap to make our website look nice.  This step isn't strictly necessary but it'll make our application snazzier.\n\n\n$ ember install:bower bootstrap\n\n\n\n\nNow we need to include the Bootstrap CSS into our build process.  Let's add the following to our \nBrocfile.js\n below \nvar app = new EmberApp();\n and above \nmodule.exports = app.toTree();\n:\n\n\napp.import('bower_components/bootstrap/dist/css/bootstrap.css');\n\n\n\n\nOur \nBrocfile.js\n should look something like this now:\n\n\n/* global require, module */\n\nvar EmberApp = require('ember-cli/lib/broccoli/ember-app');\n\nvar app = new EmberApp();\napp.import('bower_components/bootstrap/dist/css/bootstrap.css');\nmodule.exports = app.toTree();\n\n\n\n\nProTip\u2122\n Ember-CLI uses live-reloading to persist changes to the browser without the need of reloading. As long as \nhttp://localhost:4200/\n is open, you'll see changes immediately. Neat! However, if you edit \nBrocfile.js\n, like we just did in this step, you will need to \nkill\n and \nrestart\n \nember serve\n. Then refresh \nhttp://localhost:4200/\n.\n\n\nThe font of our header should have changed.\n\n\nNow let's add a big header introducing our blog.  Let's update our \napplication.hbs\n file to add a jumbotron header and wrap our page content in a Bootstrap \ncontainer\n:\n\n\n{% raw %}\n\ndiv class=\njumbotron\n\n  \ndiv class=\ncontainer\n\n    \nh1\nBernice's Blog\n/h1\n\n  \n/div\n\n\n/div\n\n\n\ndiv class=\ncontainer\n\n  {{outlet}}\n\n/div\n\n{% endraw %}\n\n\n\n\nOur site should have refreshed in our web browser now, revealing a big header for our blog.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#ready-to-code", 
            "text": "ember install  (if you didn't do this before)  ember serve  http://localhost:4200", 
            "title": "Ready to code!"
        }, 
        {
            "location": "/getting-started/#install-bootstrap", 
            "text": "Let's use Bootstrap to make our website look nice.  This step isn't strictly necessary but it'll make our application snazzier.  $ ember install:bower bootstrap  Now we need to include the Bootstrap CSS into our build process.  Let's add the following to our  Brocfile.js  below  var app = new EmberApp();  and above  module.exports = app.toTree(); :  app.import('bower_components/bootstrap/dist/css/bootstrap.css');  Our  Brocfile.js  should look something like this now:  /* global require, module */\n\nvar EmberApp = require('ember-cli/lib/broccoli/ember-app');\n\nvar app = new EmberApp();\napp.import('bower_components/bootstrap/dist/css/bootstrap.css');\nmodule.exports = app.toTree();  ProTip\u2122  Ember-CLI uses live-reloading to persist changes to the browser without the need of reloading. As long as  http://localhost:4200/  is open, you'll see changes immediately. Neat! However, if you edit  Brocfile.js , like we just did in this step, you will need to  kill  and  restart   ember serve . Then refresh  http://localhost:4200/ .  The font of our header should have changed.  Now let's add a big header introducing our blog.  Let's update our  application.hbs  file to add a jumbotron header and wrap our page content in a Bootstrap  container :  {% raw %} div class= jumbotron \n   div class= container \n     h1 Bernice's Blog /h1 \n   /div  /div  div class= container \n  {{outlet}} /div \n{% endraw %}  Our site should have refreshed in our web browser now, revealing a big header for our blog.", 
            "title": "Install Bootstrap"
        }, 
        {
            "location": "/api/", 
            "text": "API Integration\n\n\nAccessing our API with ember-data\n\n\nEmber is a client side framework and so when we have data that we want to persist, we need a back-end API.  We want an API to serve up our blog posts and allow users to view and submit comments.\n\n\nWe could use fixtures or a mock API, but some friendly back-end developers have already made a working API for us so let's use that.\n\n\nOur API is setup at https://sandiego-ember-cli-101.herokuapp.com supporting the following endpoints\n\n\n\n    \n\n        \n\n        \n\n        \n\n    \n\n    \n\n        \n\n            \nVerb\npath\nDescription\n\n        \n\n    \n\n    \n\n        \n\n            \nGET\n/blog-posts\nList of blog posts\n\n        \n\n        \n\n            \nGET\n/blog-posts/:id\nRetrieve a post\n\n        \n\n        \n\n            \nPUT\n/blog-posts/:id\nUpdate a post\n\n        \n\n        \n\n            \nDELETE\n/blog-posts/:id\nDelete a post\n\n        \n\n        \n\n            \nGET\n/comments\nList of blog comments\n\n        \n\n        \n\n            \nPOST\n/comments\nAdd a blog comment\n\n        \n\n        \n\n            \nGET\n/comments/:id\nRetrieve a comment\n\n        \n\n        \n\n            \nPUT\n/comments/:id\nUpdate a comment\n\n        \n\n        \n\n            \nDELETE\n/comments/:id\nDelete a comment\n\n        \n\n    \n\n\n\n\n\nOur API uses \nsnake_case\n in the JSON it sends, the convention for Ruby on Rails APIs. Ember expects everything to be \ncamelCase\n, so how can we connect these two nicely? Fortunately, we can use an Ember Data adapter to consumer our API and adapt it to the style we use in Ember.\n\n\nWe can set up an adapter at the level of an individual model, but since we'll be using the same API for all our models, let's set one up for the entire application:\n\n\n$ ember generate adapter application\nversion: 0.2.2\n  installing\n    create app/adapters/application.js\n  installing\n    create tests/unit/adapters/application-test.js\n\n\n\n\nLet's open up that adapter and see what is there:\n\n\nimport DS from 'ember-data';\n\nexport default DS.RESTAdapter.extend({\n});\n\n\n\n\nWe're using an Ember Data built-in adapter called the RESTAdapter. Building a custom adapter isn't too hard, but we don't need to because Ember Data already comes with an adapter designed to interact with Rails APIs.\n\n\nLet's update our file to use this adapter:\n\n\nimport DS from 'ember-data';\n\nexport default DS.ActiveModelAdapter.extend();\n\n\n\n\nFinally, to point our Ember app at the API we've set up, let's go back to our server, hit CTRL-C to stop it, and restart \nember serve\n using the proxy option to point Ember to the API we want to access:\n\n\n$ ember serve --proxy https://sandiego-ember-cli-101.herokuapp.com\nversion: 0.2.2\nProxying to https://sandiego-ember-cli-101.herokuapp.com\nLivereload server on port 35729\nServing on http://localhost:4200/", 
            "title": "API"
        }, 
        {
            "location": "/api/#api-integration", 
            "text": "", 
            "title": "API Integration"
        }, 
        {
            "location": "/api/#accessing-our-api-with-ember-data", 
            "text": "Ember is a client side framework and so when we have data that we want to persist, we need a back-end API.  We want an API to serve up our blog posts and allow users to view and submit comments.  We could use fixtures or a mock API, but some friendly back-end developers have already made a working API for us so let's use that.  Our API is setup at https://sandiego-ember-cli-101.herokuapp.com supporting the following endpoints  \n     \n         \n         \n         \n     \n     \n         \n             Verb path Description \n         \n     \n     \n         \n             GET /blog-posts List of blog posts \n         \n         \n             GET /blog-posts/:id Retrieve a post \n         \n         \n             PUT /blog-posts/:id Update a post \n         \n         \n             DELETE /blog-posts/:id Delete a post \n         \n         \n             GET /comments List of blog comments \n         \n         \n             POST /comments Add a blog comment \n         \n         \n             GET /comments/:id Retrieve a comment \n         \n         \n             PUT /comments/:id Update a comment \n         \n         \n             DELETE /comments/:id Delete a comment \n         \n       Our API uses  snake_case  in the JSON it sends, the convention for Ruby on Rails APIs. Ember expects everything to be  camelCase , so how can we connect these two nicely? Fortunately, we can use an Ember Data adapter to consumer our API and adapt it to the style we use in Ember.  We can set up an adapter at the level of an individual model, but since we'll be using the same API for all our models, let's set one up for the entire application:  $ ember generate adapter application\nversion: 0.2.2\n  installing\n    create app/adapters/application.js\n  installing\n    create tests/unit/adapters/application-test.js  Let's open up that adapter and see what is there:  import DS from 'ember-data';\n\nexport default DS.RESTAdapter.extend({\n});  We're using an Ember Data built-in adapter called the RESTAdapter. Building a custom adapter isn't too hard, but we don't need to because Ember Data already comes with an adapter designed to interact with Rails APIs.  Let's update our file to use this adapter:  import DS from 'ember-data';\n\nexport default DS.ActiveModelAdapter.extend();  Finally, to point our Ember app at the API we've set up, let's go back to our server, hit CTRL-C to stop it, and restart  ember serve  using the proxy option to point Ember to the API we want to access:  $ ember serve --proxy https://sandiego-ember-cli-101.herokuapp.com\nversion: 0.2.2\nProxying to https://sandiego-ember-cli-101.herokuapp.com\nLivereload server on port 35729\nServing on http://localhost:4200/", 
            "title": "Accessing our API with ember-data"
        }
    ]
}