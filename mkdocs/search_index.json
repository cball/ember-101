{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Ember-CLI 101 workshop hosted by \nSan Diego Ember\n.\n\n\nPre-event setup instructions\n\n\n\n\nInstall Git\n\n\nInstall Node.js\n\n\nSetup NPM for non-sudo installation\n\n\nThe easiest way to do this is by checking out \nthis awesome shell script\n that will do it for you\n\n\nNPM is the node package manager. It will automatically be installed when you install node.\n\n\nNPM installs packages locally (within the directory it is invoked in) for per-project modules, or globally for packages you want accessible everywhere.\n\n\nHowever, by default NPM installs global packages in a root-restricted location, requiring SUDO to install. This creates a huge headache. As an alternative, before you install any packages, follow \nthis guide\n to configure your NPM to install in your home directory without requiring sudo.\n\n\n\n\n\n\nInstall \nBower\n: \nnpm i -g bower\n\n\nInstall \nEmber-CLI\n: \nnpm i -g ember-cli\n\n\nAnd create a new project named \nworkshop\n: \nember new workshop\n\n\nMove into the \nworkshop\n directory: \ncd workshop\n\n\n\n\nReduce the glue\n\n\nWeb application development can involve a lot of repetition.  Attempts to reduce the repetition involved in web development has given rise to a variety of scaffolding tools and best practices. These scaffolding tools are all trying to do the same thing: reduce the amount of work necessary to \"get started\" by providing a set of \"best practices\" that are enabled default.  These choices include things like:\n\n\n\n\nApplication directory structure\n\n\nGenerators for common components\n\n\nModularity choices (AMD/node modules/etc)\n\n\nBuild system\n\n\nAsset compilation \n minification\n\n\nTesting framework and setup\n\n\n\n\nEmber-CLI\n\n\nEmber-CLI\n provides choices for all of the aforementioned areas.  We'll dive into some of these choices in more detail later but at a high level Ember-CLI builds in:\n\n\n\n\nA directory structure which we'll explore more later\n\n\nGenerators for all common components\n\n\nES6 modules transpiled to AMD\n\n\nBroccoli build tool for builds. (Fast and extensible with plugin architecture\n\n\nAsset minification also via Broccoli\n\n\nQUnit for testing\n\n\n\n\nModules\n\n\nModules allow you to divide logical portions of code into smaller, functional pieces and include them as needed. As your application grows, smaller pieces of functional code become easier to manage, support, maintain and test. To learn more about JS Modules, check out \njsmodules.io\n\n\nNaming best practices\n\n\n\n\nCode\n\n\nTitleCase\n naming of classes\n\n\ncamelCase\n naming of attributes\n\n\nuse modules, avoid globals\n\n\nreusable code \u2192 components, mixins, add-ons\n\n\n\n\n\n\nFiles\n\n\nkebab-case-naming.js\n\n\nchildren in subdirectory \u2192 \nroutes/invoices/edit.js\n \n \nroutes/invoices/new.js", 
            "title": "Home"
        }, 
        {
            "location": "/#pre-event-setup-instructions", 
            "text": "Install Git  Install Node.js  Setup NPM for non-sudo installation  The easiest way to do this is by checking out  this awesome shell script  that will do it for you  NPM is the node package manager. It will automatically be installed when you install node.  NPM installs packages locally (within the directory it is invoked in) for per-project modules, or globally for packages you want accessible everywhere.  However, by default NPM installs global packages in a root-restricted location, requiring SUDO to install. This creates a huge headache. As an alternative, before you install any packages, follow  this guide  to configure your NPM to install in your home directory without requiring sudo.    Install  Bower :  npm i -g bower  Install  Ember-CLI :  npm i -g ember-cli  And create a new project named  workshop :  ember new workshop  Move into the  workshop  directory:  cd workshop", 
            "title": "Pre-event setup instructions"
        }, 
        {
            "location": "/#reduce-the-glue", 
            "text": "Web application development can involve a lot of repetition.  Attempts to reduce the repetition involved in web development has given rise to a variety of scaffolding tools and best practices. These scaffolding tools are all trying to do the same thing: reduce the amount of work necessary to \"get started\" by providing a set of \"best practices\" that are enabled default.  These choices include things like:   Application directory structure  Generators for common components  Modularity choices (AMD/node modules/etc)  Build system  Asset compilation   minification  Testing framework and setup", 
            "title": "Reduce the glue"
        }, 
        {
            "location": "/#ember-cli", 
            "text": "Ember-CLI  provides choices for all of the aforementioned areas.  We'll dive into some of these choices in more detail later but at a high level Ember-CLI builds in:   A directory structure which we'll explore more later  Generators for all common components  ES6 modules transpiled to AMD  Broccoli build tool for builds. (Fast and extensible with plugin architecture  Asset minification also via Broccoli  QUnit for testing", 
            "title": "Ember-CLI"
        }, 
        {
            "location": "/#modules", 
            "text": "Modules allow you to divide logical portions of code into smaller, functional pieces and include them as needed. As your application grows, smaller pieces of functional code become easier to manage, support, maintain and test. To learn more about JS Modules, check out  jsmodules.io", 
            "title": "Modules"
        }, 
        {
            "location": "/#naming-best-practices", 
            "text": "Code  TitleCase  naming of classes  camelCase  naming of attributes  use modules, avoid globals  reusable code \u2192 components, mixins, add-ons    Files  kebab-case-naming.js  children in subdirectory \u2192  routes/invoices/edit.js     routes/invoices/new.js", 
            "title": "Naming best practices"
        }, 
        {
            "location": "/understanding-basics/", 
            "text": "Project Organization: High level\n\n\nIn the \nPre-event setup instructions\n section you generated a new ember project called \nworkshop\n. Let's step inside and start exploring:\n\n\n$ cd workshop\n$ ls -1\nREADME.md\napp\nbower.json\nbower_components\nconfig\nember-cli-build.js\nnode_modules\npackage.json\npublic\ntestem.js\ntests\nvendor\n\n\n\n\nNode Moduules\n\n\nThe first thing to notice is the file \npackage.json\n and the directory \nnode_modules\n. These are from \nNPM\n, and if you're new to NPM, take a look at what is in the \npackage.json\n file. This file contains information about what NPM modules are required to run and develop our app. You'll see that the packages needed for broccoli and Ember-CLI are specified here. When using Ember-CLI you won't often edit this directly. If you were to install any Ember-CLI addons yourself, you would see them show up in here as well. The packages specified in \npackage.json\n will be installed in the \nnode_modules\n directory.\n\n\nBower Components\n\n\nThe next thing to look at is the file \nbower.json\n and the \nbower_components\n directory. These are similar to \npackage.json\n and \nnode_modules\n. Bower has become the standard for front-end package management and our Ember-CLI application will use it to manage some of our dependencies. If you open up \nbower.json\n you'll see that our application comes out of the box with not only Ember but Ember Data (for data persistence), and QUnit (for testing).\n\n\nTests\n\n\nEmber-CLI comes out-of-the box with a testing framework and provides some helpers to make testing easier. You can test models, routes, controllers and components, and you can test user flows.\n\n\nUnit tests allow us to focus on specific functionality of a module and do not require the entire Ember application be running. Acceptance tests, also called integration or acceptance tests, are used to test the flow of your app. They emulate user interactions throughout your application and using helpers you can make assertions about the expected functionality.\n\n\nPublic and Vendor\n\n\nYou may be wondering where images, fonts and other miscellaneous asset files should go. The answer is the \npublic\n directory. These will be served at the root of your application.\n\n\nSimilarly, you may have JavaScript or CSS dependencies that are not in bower. These can be stored in the \nvendor\n directory. Loading vendor files is not something we will cover in this workshop.\n\n\nApp\n\n\nThe \napp\n directory is where we're going to put all of our own application code.  It is carefully structured with an appropriate place for each type of module:\n\n\n$ ls -1\napp.js\ncomponents\ncontrollers\nhelpers\nindex.html\nmodels\nresolver.js\nrouter.js\nroutes\nstyles\ntemplates\n\n\n\n\nSome of these may sound familiar to you, while others may be brand new.  Don't worry yet if you don't know what all of these different pieces are.  We'll get to them one by one.", 
            "title": "Understanding Basics"
        }, 
        {
            "location": "/understanding-basics/#project-organization-high-level", 
            "text": "In the  Pre-event setup instructions  section you generated a new ember project called  workshop . Let's step inside and start exploring:  $ cd workshop\n$ ls -1\nREADME.md\napp\nbower.json\nbower_components\nconfig\nember-cli-build.js\nnode_modules\npackage.json\npublic\ntestem.js\ntests\nvendor", 
            "title": "Project Organization: High level"
        }, 
        {
            "location": "/understanding-basics/#node-moduules", 
            "text": "The first thing to notice is the file  package.json  and the directory  node_modules . These are from  NPM , and if you're new to NPM, take a look at what is in the  package.json  file. This file contains information about what NPM modules are required to run and develop our app. You'll see that the packages needed for broccoli and Ember-CLI are specified here. When using Ember-CLI you won't often edit this directly. If you were to install any Ember-CLI addons yourself, you would see them show up in here as well. The packages specified in  package.json  will be installed in the  node_modules  directory.", 
            "title": "Node Moduules"
        }, 
        {
            "location": "/understanding-basics/#bower-components", 
            "text": "The next thing to look at is the file  bower.json  and the  bower_components  directory. These are similar to  package.json  and  node_modules . Bower has become the standard for front-end package management and our Ember-CLI application will use it to manage some of our dependencies. If you open up  bower.json  you'll see that our application comes out of the box with not only Ember but Ember Data (for data persistence), and QUnit (for testing).", 
            "title": "Bower Components"
        }, 
        {
            "location": "/understanding-basics/#tests", 
            "text": "Ember-CLI comes out-of-the box with a testing framework and provides some helpers to make testing easier. You can test models, routes, controllers and components, and you can test user flows.  Unit tests allow us to focus on specific functionality of a module and do not require the entire Ember application be running. Acceptance tests, also called integration or acceptance tests, are used to test the flow of your app. They emulate user interactions throughout your application and using helpers you can make assertions about the expected functionality.", 
            "title": "Tests"
        }, 
        {
            "location": "/understanding-basics/#public-and-vendor", 
            "text": "You may be wondering where images, fonts and other miscellaneous asset files should go. The answer is the  public  directory. These will be served at the root of your application.  Similarly, you may have JavaScript or CSS dependencies that are not in bower. These can be stored in the  vendor  directory. Loading vendor files is not something we will cover in this workshop.", 
            "title": "Public and Vendor"
        }, 
        {
            "location": "/understanding-basics/#app", 
            "text": "The  app  directory is where we're going to put all of our own application code.  It is carefully structured with an appropriate place for each type of module:  $ ls -1\napp.js\ncomponents\ncontrollers\nhelpers\nindex.html\nmodels\nresolver.js\nrouter.js\nroutes\nstyles\ntemplates  Some of these may sound familiar to you, while others may be brand new.  Don't worry yet if you don't know what all of these different pieces are.  We'll get to them one by one.", 
            "title": "App"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Ready to code!\n\n\nNow that we have reviewed the contents ember-cli sets us up with for development, we are ready to get coding. One of the many commands ember-cli provides us is \nserve\n which will launch the server with live-reload. Any time we make changes to the application we should see this instantly reflected in any of the browser we have open to the server.\n\n\n\n\nember serve\n\n\nVisit \nhttp://localhost:4200\n in your browser\n\n\n\n\nInstall Bootstrap\n\n\nLet's use Bootstrap to make our website look nice. This step isn't strictly necessary but it'll make our application snazzier without us having to do much styling work.\n\n\n$ bower install bootstrap --save\n\n\n\n\nNow we need to include the Bootstrap CSS into our build process.  Let's add the following to our \nember-cli-build.js\n just above \nreturn app.toTree();\n:\n\n\napp.import('bower_components/bootstrap/dist/css/bootstrap.css');\n\n\n\n\nOur \nember-cli-build.js\n should look something like this now:\n\n\n/*jshint node:true*/\n/* global require, module */\nvar EmberApp = require('ember-cli/lib/broccoli/ember-app');\n\nmodule.exports = function(defaults) {\n  var app = new EmberApp(defaults, {\n    // Add options here\n  });\n\n  // Use `app.import` to add additional libraries to the generated\n  // output files.\n  //\n  // If you need to use different assets in different\n  // environments, specify an object as the first parameter. That\n  // object's keys should be the environment name and the values\n  // should be the asset to use in that environment.\n  //\n  // If the library that you are including contains AMD or ES6\n  // modules that you would like to import into your application\n  // please specify an object with the list of modules as keys\n  // along with the exports of each module as its value.\n\n  // Add bootstrap to our build\n  app.import('bower_components/bootstrap/dist/css/bootstrap.css');\n\n  return app.toTree();\n};\n\n\n\n\nProTip\u2122\n As we mentioned before, ember-cli uses live-reloading to persist changes to the browser without the need of reloading. As long as \nhttp://localhost:4200/\n is open, you'll see changes immediately. Neat! However, if you edit \nember-cli-build.js\n, like we just did in this step, you will need to \nkill\n and \nrestart\n \nember serve\n. Then refresh \nhttp://localhost:4200/\n.\n\n\nThe font of our header should have changed.\n\n\nNow let's add a big header introducing our blog.  Let's update our \napplication.hbs\n file to add a jumbotron header and wrap our page content in a Bootstrap \ncontainer\n:\n\n\n{% raw %}\n\ndiv class=\njumbotron\n\n  \ndiv class=\ncontainer\n\n    \nh1\nBernice's Blog\n/h1\n\n  \n/div\n\n\n/div\n\n\n\ndiv class=\ncontainer\n\n  {{outlet}}\n\n/div\n\n{% endraw %}\n\n\n\n\nOur site should have refreshed in our web browser now, revealing a big header for our blog.\n\n\nCheckout our completed version\n\n\nThroughout the workshop if you need to compare your app at a point in time to the steps in this workshop, head on over to the \nember-101-app repository\n where each step has been tagged to match this walk-through.\n\n\nIf you wanted to checkout the code at the end of this step, check out the \ngetting-started\n \ntag\n.", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#ready-to-code", 
            "text": "Now that we have reviewed the contents ember-cli sets us up with for development, we are ready to get coding. One of the many commands ember-cli provides us is  serve  which will launch the server with live-reload. Any time we make changes to the application we should see this instantly reflected in any of the browser we have open to the server.   ember serve  Visit  http://localhost:4200  in your browser", 
            "title": "Ready to code!"
        }, 
        {
            "location": "/getting-started/#install-bootstrap",  
            "text": "Let's use Bootstrap to make our website look nice. This step isn't strictly necessary but it'll make our application snazzier without us having to do much styling work.  $ bower install bootstrap --save  Now we need to include the Bootstrap CSS into our build process.  Let's add the following to our  ember-cli-build.js  just above  return app.toTree(); :  app.import('bower_components/bootstrap/dist/css/bootstrap.css');  Our  ember-cli-build.js  should look something like this now:  /*jshint node:true*/\n/* global require, module */\nvar EmberApp = require('ember-cli/lib/broccoli/ember-app');\n\nmodule.exports = function(defaults) {\n  var app = new EmberApp(defaults, {\n    // Add options here\n  });\n\n  // Use `app.import` to add additional libraries to the generated\n  // output files.\n  //\n  // If you need to use different assets in different\n  // environments, specify an object as the first parameter. That\n  // object's keys should be the environment name and the values\n  // should be the asset to use in that environment.\n  //\n  // If the library that you are including contains AMD or ES6\n  // modules that you would like to import into your application\n  // please specify an object with the list of modules as keys\n  // along with the exports of each module as its value.\n\n  // Add bootstrap to our build\n  app.import('bower_components/bootstrap/dist/css/bootstrap.css');\n\n  return app.toTree();\n};  ProTip\u2122  As we mentioned before, ember-cli uses live-reloading to persist changes to the browser without the need of reloading. As long as  http://localhost:4200/  is open, you'll see changes immediately. Neat! However, if you edit  ember-cli-build.js , like we just did in this step, you will need to  kill  and  restart   ember serve . Then refresh  http://localhost:4200/ .  The font of our header should have changed.  Now let's add a big header introducing our blog.  Let's update our  application.hbs  file to add a jumbotron header and wrap our page content in a Bootstrap  container :  {% raw %} div class= jumbotron \n   div class= container \n     h1 Bernice's Blog /h1 \n   /div  /div  div class= container \n  {{outlet}} /div \n{% endraw %}  Our site should have refreshed in our web browser now, revealing a big header for our blog.", 
            "title": "Install Bootstrap"
        }, 
        {
            "location": "/getting-started/#checkout-our-completed-version", 
            "text": "Throughout the workshop if you need to compare your app at a point in time to the steps in this workshop, head on over to the  ember-101-app repository  where each step has been tagged to match this walk-through.  If you wanted to checkout the code at the end of this step, check out the  getting-started   tag .", 
            "title": "Checkout our completed version"
        }, 
        {
            "location": "/api/", 
            "text": "Accessing our API with ember-data\n\n\nEmber is a client side framework and so when we have data that we want to persist we need a back-end API.  We want an API to serve up our blog posts and allow users to view and submit comments.\n\n\nWe could use fixtures or a mock API but some friendly back-end developers have already made a working API for us so let's use that.\n\n\nOur API is setup at https://ember-101-api.herokuapp.com supporting the following endpoints\n\n\n\n  \n\n    \n\n    \n\n    \n\n  \n\n  \n\n    \n\n      \nVerb\npath\nDescription\n\n    \n\n  \n\n  \n\n    \n\n        \nGET\n/blog-posts\nList of blog posts\n\n    \n\n    \n\n        \nGET\n/blog-posts/:id\nRetrieve a post\n\n    \n\n    \n\n        \nPUT\n/blog-posts/:id\nUpdate a post\n\n    \n\n    \n\n        \nDELETE\n/blog-posts/:id\nDelete a post\n\n    \n\n    \n\n        \nGET\n/comments\nList of blog comments\n\n    \n\n    \n\n        \nPOST\n/comments\nAdd a blog comment\n\n    \n\n    \n\n        \nGET\n/comments/:id\nRetrieve a comment\n\n    \n\n    \n\n        \nPUT\n/comments/:id\nUpdate a comment\n\n    \n\n    \n\n        \nDELETE\n/comments/:id\nDelete a comment\n\n    \n\n  \n\n\n\n\n\nOur API uses \nsnake_case\n in the JSON it sends, the convention for Ruby on Rails APIs. Ember expects everything to be \ncamelCase\n, so how can we connect these two nicely? Fortunately, we can use an Ember Data adapter to consumer our API and adapt it to the style we use in Ember.\n\n\nApplication Adapter\n\n\nWe can set up an adapter at the level of an individual model, but since we'll be using the same API for all our models, let's set one up for the entire application:\n\n\n$ ember generate adapter application\nversion: 0.2.2\n  installing\n    create app/adapters/application.js\n  installing\n    create tests/unit/adapters/application-test.js\n\n\n\n\nLet's open up that adapter and see what is there:\n\n\nimport JSONAPIAdapter from 'ember-data/adapters/json-api';\n\nexport default JSONAPIAdapter.extend({\n});\n\n\n\n\nWe're using an Ember Data built-in adapter called the JSONAPIAdapter. Building a custom adapter isn't too hard, but we don't need to because we're going to use the default.\n\n\nFinally, to point our Ember app at the API we've set up, let's go back to our server, hit \nCTRL-C\n to stop it, and restart \nember serve\n using the proxy option to point Ember to the API we want to access:\n\n\n$ ember serve --proxy https://ember-101-api.herokuapp.com\nProxying to https://ember-101-api.herokuapp.com\nLivereload server on http://localhost:49152\nServing on http://localhost:4200/", 
            "title": "API"
        }, 
        {
            "location": "/api/#accessing-our-api-with-ember-data", 
            "text": "Ember is a client side framework and so when we have data that we want to persist we need a back-end API.  We want an API to serve up our blog posts and allow users to view and submit comments.  We could use fixtures or a mock API but some friendly back-end developers have already made a working API for us so let's use that.  Our API is setup at https://ember-101-api.herokuapp.com supporting the following endpoints  \n   \n     \n     \n     \n   \n   \n     \n       Verb path Description \n     \n   \n   \n     \n         GET /blog-posts List of blog posts \n     \n     \n         GET /blog-posts/:id Retrieve a post \n     \n     \n         PUT /blog-posts/:id Update a post \n     \n     \n         DELETE /blog-posts/:id Delete a post \n     \n     \n         GET /comments List of blog comments \n     \n     \n         POST /comments Add a blog comment \n     \n     \n         GET /comments/:id Retrieve a comment \n     \n     \n         PUT /comments/:id Update a comment \n     \n     \n         DELETE /comments/:id Delete a comment \n     \n     Our API uses  snake_case  in the JSON it sends, the convention for Ruby on Rails APIs. Ember expects everything to be  camelCase , so how can we connect these two nicely? Fortunately, we can use an Ember Data adapter to consumer our API and adapt it to the style we use in Ember.", 
            "title": "Accessing our API with ember-data"
        }, 
        {
            "location": "/api/#application-adapter", 
            "text": "We can set up an adapter at the level of an individual model, but since we'll be using the same API for all our models, let's set one up for the entire application:  $ ember generate adapter application\nversion: 0.2.2\n  installing\n    create app/adapters/application.js\n  installing\n    create tests/unit/adapters/application-test.js  Let's open up that adapter and see what is there:  import JSONAPIAdapter from 'ember-data/adapters/json-api';\n\nexport default JSONAPIAdapter.extend({\n});  We're using an Ember Data built-in adapter called the JSONAPIAdapter. Building a custom adapter isn't too hard, but we don't need to because we're going to use the default.  Finally, to point our Ember app at the API we've set up, let's go back to our server, hit  CTRL-C  to stop it, and restart  ember serve  using the proxy option to point Ember to the API we want to access:  $ ember serve --proxy https://ember-101-api.herokuapp.com\nProxying to https://ember-101-api.herokuapp.com\nLivereload server on http://localhost:49152\nServing on http://localhost:4200/", 
            "title": "Application Adapter"
        }, 
        {
            "location": "/blog-post/", 
            "text": "Blog post model\n\n\nFor our test application, we're going to create a blog. Let's start off by using a generator to create a model for the blogPost. We'll give it a couple of basic fields and take a look at what happens.\n\n\n$ ember generate model blog-post title:string body:string\ninstalling model\n  create app/models/blog-post.js\ninstalling model-test\n  create tests/unit/models/blog-post-test.js\n\n\n\n\nOK, Ember-CLI has just created for us both a model file in \napp/models\n and a test file in \ntests/unit/models\n.  Let's take a look at the model and see what it contains:\n\n\nimport Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  title: attr('string'),\n  body: attr('string')\n});\n\n\n\n\nWhat is that funky syntax?  \nimport Model from 'ember-data/model\n and \nexport default Model.extend()\n?  Welcome to the world of tomorrow!\n\n\nThose \nimport\n and \nexport\n statements use ECMAScript 6 module syntax. Thanks to the magic of transpilers, we can already use them today even though no browsers support ES6 yet. This should look familiar if you have used Node.js or AMD modules, there's just slightly different syntax.  We're importing a module from 'ember-data/model' and calling it \nModel\n.  Then we're extending the \nModel\n class and using that as our module export.\n\n\nOur model specifies every field it should have, in this case \ntitle\n and \nbody\n.  If we later decide we want another field (perhaps a published date) we just need to add it to our model:\n\n\nimport Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  title: attr('string'),\n  body: attr('string'),\n  publishedDate: attr('date')\n});\n\n\n\n\n\nTest our blog post model\n\n\nTesting can seem daunting if you put it off for too long so lets get right to it and write a test for that model we just created. Ember-CLI has us covered. When we generated our blog post model Ember-CLI also generated a test module for our model:\n\n\n$ ls tests/unit/models\nblog-post-test.js\n\n\n\n\nPretty cool, huh? Let's open up \ntests/unit/models/blog-post-test.js\n and see what Ember-CLI generated for us:\n\n\nimport { moduleForModel, test } from 'ember-qunit';\n\nmoduleForModel('blog-post', 'Unit | Model | blog post', {\n  // Specify the other units that are required for this test.\n  needs: []\n});\n\ntest('it exists', function(assert) {\n  let model = this.subject();\n  // let store = this.store();\n  assert.ok(!!model);\n});\n\n\n\n\n\nThat looks like a lot! First is the \nimport\n statement. This imports the \nmoduleForModel\n and \ntest\n helpers we will need from \nember-qunit\n for writing our test.\n\n\nThe first section you see, \nmoduleForModel\n, is where any necessary loading for the model testing will be done. Each unit test is self-contained, so any dependencies (for example if one model depends on another) must be defined here. We don't need to worry about this for our simple blog post model \nyet\n.\n\n\nThe next section, \ntest\n, shows how we define an individual test. One test can have many assertions but should test only one thing. The generator created a default test which asserts that our model exists.\n\n\nSince we have about as much as we can test in here already for our small model, let's make sure the tests pass by visiting \nhttp://localhost:4200/tests\n in your browser.\n\n\nAdding blog posts to the homepage\n\n\nCreate an index route\n\n\nIf we want to see blog posts on our website, we need to render them into our HTML.  Ember's view layer places routes and their associated URLs front and center.  The way to show something is to create a route and associated template.\n\n\nLet's start once again from a generator, this time for our index page route:\n\n\n$ ember generate route index\ninstalling route\n  create app/routes/index.js\n  create app/templates/index.hbs\ninstalling route-test\n  create tests/unit/routes/index-test.js\n\n\n\n\nProTip\u2122\n If you ever need to know what generators are available, just type \nember help generate\n and enjoy a deliciously long list of generating goodness.\n\n\nThis creates a few files for our index route and template file.\n\n\nLooking at \napp/routes/index.js\n we see:\n\n\nimport Ember from 'ember';\n\nexport default Ember.Route.extend({\n});\n\n\n\n\nUpdate an index template\n\n\nLet's take a look at the template file that was generated for us in \napp/templates/index.hbs\n:\n\n\n{{outlet}}\n\n\n\n\nJust this funky thing called \n{{outlet}}\n. Ember.js uses handlebars for templating, and the \noutlet\n variable is a special variable that Ember uses to say \"insert any subtemplates here\". If you've done anything with Ruby on Rails, think \nyield\n and you'll be awfully close. We're not adding any subtemplates to our \nindex\n template so let's remove the \n{{outlet}}\n and add a sample post:\n\n\narticle\n\n  \nheader class=\npage-header\n\n    \nh2\nMy Blog Post\n/h2\n\n  \n/header\n\n  \np\nThis is a test post.\n/p\n\n\n/article\n\n\n\n\n\nGo look at the website in your browser again. Our 'My Blog Post' header should appear nicely beneath our big site header.\n\n\nPutting our posts on the page\n\n\nSo far we have only put some HTML on our page. Let's use the API to show our actual blog posts.\n\n\nFirst let's add a \nmodel\n to our route in \napp/routes/index.js\n. One of the jobs of routes is to provide a model to their template. Our model should be a list of blog posts retrieved from our API.\n\n\nWe could manually provide list of blog posts as our model:\n\n\nimport Ember from 'ember';\n\nexport default Ember.Route.extend({\n  model: function() {\n    return [{\n      title: \nFirst post\n,\n      body: \nThis is the post body.\n\n    }];\n  }\n});\n\n\n\n\nInstead let's use the data store to retrieve all of our blog posts:\n\n\nimport Ember from 'ember';\n\nexport default Ember.Route.extend({\n  model: function() {\n    return this.store.findAll('blog-post');\n  }\n});\n\n\n\n\nNow we should update our index template to loop over each of our blog posts and render it:\n\n\n{{#each model as |post|}}\n  \narticle\n\n    \nheader class=\npage-header\n\n      \nh2\n{{post.title}}\n/h2\n\n    \n/header\n\n    \np\n{{post.body}}\n/p\n\n  \n/article\n\n{{/each}}\n\n\n\n\nThe handlebars each helper allows us to enumerate over a list of items. This should print out all of our blog posts to the page. Let's check out our homepage in our browser again and make sure it worked.\n\n\nAdditional Blog post route(s)\n\n\nWhat if we want to share a link to one of our blog posts?  To do that, we would need a page for each blog post.  Let's make those!\n\n\nCreate the route\n\n\nLet's start by using a generator to make the new files we'll need:\n\n\n$ ember generate route blog-post --path=/post/:blog_post_id\ninstalling route\n  create app/routes/blog-post.js\n  create app/templates/blog-post.hbs\nupdating router\n  add route blog-post\ninstalling route-test\n  create tests/unit/routes/blog-post-test.js\n\n\n\n\nThis creates a few files, and also adds some stuff to your  \napp/router.js\n:\n\n\nimport Ember from 'ember';\nimport config from './config/environment';\n\nconst Router = Ember.Router.extend({\n  location: config.locationType\n});\n\nRouter.map(function() {\n  this.route('blog-post', {\n    path: '/post/:blog_post_id'\n  });\n});\n\nexport default Router;\n\n\n\n\nHere it has defined a route for us with a dynamic segment in the path, \n:blog_post_id\n. This dynamic segment will be extracted from the URL and passed into the \nmodel\n hook on the \npost\n route. We can then use this parameter to look up that exact \nblog-post\n in the data store. So let's open up \napp/routes/blog-post.js\n that was generated for us and do just that.\n\n\nimport Ember from 'ember';\n\nexport default Ember.Route.extend({\n  model: function(params) {\n    return this.store.find('blog-post', params.blog_post_id);\n  }\n});\n\n\n\n\nUpdate the template\n\n\nIn order to make sure this is working, let's add some markup to \napp/templates/blog-post.hbs\n that will display a post. This file doesn't exist yet, so be sure to add it.\n\n\narticle\n\n  \nheader class=\npage-header\n\n    \nh1\n{{model.title}}\n/h1\n\n  \n/header\n\n  \np\n{{model.body}}\n/p\n\n\n/article\n\n\n\n\n\nSince we happen to know there is a blog post with \nid: 1\n on our API server, we can manually visit \nhttp://localhost:4200/post/1\n in our browser to test with an example blog post.\n\n\nThe magic of Ember-Data\n\n\nEmber-Data's REST Adapter comes with some freebies to save us time and unnecessary code. The adapter that we are using, \nJSONAPIAdapter\n is an extension of the REST Adapter, so we get to take advantage of this automagic if our application follows the URL conventions expected of the REST Adapter.\n\n\nBased on our route's dynamic URL segments the REST Adapter will make the proper calls to the application's API for the model hook.\n\n\n\n    \n\n        \n\n        \n\n        \n\n    \n\n  \n\n    \n\n      \nAction\n\n      \nHTTP Verb\n\n      \nURL\n\n    \n\n  \n\n  \n\n    \n\n      \nFind\n\n      \nGET\n\n      \n/post/:blog_post_id\n\n    \n\n    \n\n      \nFind All\n\n      \nGET\n\n      \n/post\n\n    \n\n    \n\n      \nUpdate\n\n      \nPUT\n\n      \n/post/:blog_post_id\n\n    \n\n    \n\n      \nCreate\n\n      \nPOST\n\n      \n/post\n\n    \n\n    \n\n      \nDelete\n\n      \nDELETE\n\n      \n/post/:blog_post_id\n\n    \n\n  \n\n\n\n\n\nProTip\u2122\n The store action determines the model name based on the defined dynamic segment. In our example \n:blog_post_id\n contains the proper snake-case name for our model with the suffix \n_id\n appended.\n\n\nTo confirm that this works, \ndelete the \napp/routes/blog-post.js\n file\n and verify that our blog post page (http://localhost:4200/post/1) still works properly after reload.\n\n\nEmber-CLI created a route test file automatically as well. To make sure your tests continue to pass, if you delete \napp/routes/blog-post.js\n you should also delete \ntests/unit/routes/blog-post-test.js\n\n\nHandlebars link-to helper\n\n\nNow that we have unique URLs for each blog post, we can link to these URLs from our index route.\n\n\nTo add these links open up the \napp/templates/index.hbs\n file and add a \nlink-to\n Handlebars helper around our blog title:\n\n\n{{#each model as |post|}}\n  \narticle\n\n    \nheader class=\npage-header\n\n      \nh2\n\n        {{#link-to 'blog-post' post}} {{post.title}} {{/link-to}}\n      \n/h2\n\n    \n/header\n\n    \np\n{{post.body}}\n/p\n\n  \n/article\n\n{{/each}}\n\n\n\n\nNow take a look at \nhttp://localhost:4200\n and title links should appear. \nClick it!\n And now you're at the page for our blog post.\n\n\nAcceptance testing\n\n\nWith some user interaction added to our application we can now create an acceptance test. The user flow for this test will be:\n\n\n\n\nVisit \n/\n\n\nClick the first blog link\n\n\nVerify that the URL now matches \n/post/:blog_post_id\n\n\n\n\nFirst we will have to generate our acceptance test.\n\n\n$ ember generate acceptance-test blog-post-show\ninstalling acceptance-test\n  create tests/acceptance/blog-post-show-test.js\n\n\n\n\nOpen the created file \ntests/acceptance/blog-post-show-test.js\n and see what is there:\n\n\nimport { test } from 'qunit';\nimport moduleForAcceptance from 'workshop/tests/helpers/module-for-acceptance';\n\nmoduleForAcceptance('Acceptance | blog post show');\n\ntest('visiting /blog-post-show', function(assert) {\n  visit('/blog-post-show');\n\n  andThen(function() {\n    assert.equal(currentURL(), '/blog-post-show');\n  });\n});\n\n\n\n\nLet's first rename this test to something more applicable and remove the stuff inside.\n\n\ntest('visit blog post from index', function(assert) {\n\n});\n\n\n\n\nThere are a few helpers available to us that we will use \na lot\n when writing acceptance tests.\n\n\n\n\nvisit(route)\n: Visits the given route\n\n\nclick(selector or element)\n: Clicks the element and triggers any actions triggered by that element's click event\n\n\nandThen(callback)\n: Waits for any preceding promises to continue\n\n\n\n\nSince \nvisit\n and \nclick\n are both asynchronous helpers we need to wrap subsequent logic in \nandThen\n to make sure actions complete before continuing onto the next step.\n\n\nNow we will code out the steps listed above to test that we can link to a blog post from index.\n\n\ntest('visit blog post from index', function(assert) {\n  visit('/');\n  let blogSelector = 'article:first-of-type a';\n\n  andThen(function() {\n    click(blogSelector);\n  });\n\n  andThen(function() {\n    assert.equal(currentURL(), '/post/1');\n  });\n});\n\n\n\n\nVerify the tests are passing by visiting \nhttp://localhost:4200/tests\n in the browser.", 
            "title": "Blog Post"
        }, 
        {
            "location": "/blog-post/#blog-post-model", 
            "text": "For our test application, we're going to create a blog. Let's start off by using a generator to create a model for the blogPost. We'll give it a couple of basic fields and take a look at what happens.  $ ember generate model blog-post title:string body:string\ninstalling model\n  create app/models/blog-post.js\ninstalling model-test\n  create tests/unit/models/blog-post-test.js  OK, Ember-CLI has just created for us both a model file in  app/models  and a test file in  tests/unit/models .  Let's take a look at the model and see what it contains:  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  title: attr('string'),\n  body: attr('string')\n});  What is that funky syntax?   import Model from 'ember-data/model  and  export default Model.extend() ?  Welcome to the world of tomorrow!  Those  import  and  export  statements use ECMAScript 6 module syntax. Thanks to the magic of transpilers, we can already use them today even though no browsers support ES6 yet. This should look familiar if you have used Node.js or AMD modules, there's just slightly different syntax.  We're importing a module from 'ember-data/model' and calling it  Model .  Then we're extending the  Model  class and using that as our module export.  Our model specifies every field it should have, in this case  title  and  body .  If we later decide we want another field (perhaps a published date) we just need to add it to our model:  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  title: attr('string'),\n  body: attr('string'),\n  publishedDate: attr('date')\n});", 
            "title": "Blog post model"
        }, 
        {
            "location": "/blog-post/#test-our-blog-post-model", 
            "text": "Testing can seem daunting if you put it off for too long so lets get right to it and write a test for that model we just created. Ember-CLI has us covered. When we generated our blog post model Ember-CLI also generated a test module for our model:  $ ls tests/unit/models\nblog-post-test.js  Pretty cool, huh? Let's open up  tests/unit/models/blog-post-test.js  and see what Ember-CLI generated for us:  import { moduleForModel, test } from 'ember-qunit';\n\nmoduleForModel('blog-post', 'Unit | Model | blog post', {\n  // Specify the other units that are required for this test.\n  needs: []\n});\n\ntest('it exists', function(assert) {\n  let model = this.subject();\n  // let store = this.store();\n  assert.ok(!!model);\n});  That looks like a lot! First is the  import  statement. This imports the  moduleForModel  and  test  helpers we will need from  ember-qunit  for writing our test.  The first section you see,  moduleForModel , is where any necessary loading for the model testing will be done. Each unit test is self-contained, so any dependencies (for example if one model depends on another) must be defined here. We don't need to worry about this for our simple blog post model  yet .  The next section,  test , shows how we define an individual test. One test can have many assertions but should test only one thing. The generator created a default test which asserts that our model exists.  Since we have about as much as we can test in here already for our small model, let's make sure the tests pass by visiting  http://localhost:4200/tests  in your browser.", 
            "title": "Test our blog post model"
        }, 
        {
            "location": "/blog-post/#adding-blog-posts-to-the-homepage", 
            "text": "", 
            "title": "Adding blog posts to the homepage"
        }, 
        {
            "location": "/blog-post/#create-an-index-route", 
            "text": "If we want to see blog posts on our website, we need to render them into our HTML.  Ember's view layer places routes and their associated URLs front and center.  The way to show something is to create a route and associated template.  Let's start once again from a generator, this time for our index page route:  $ ember generate route index\ninstalling route\n  create app/routes/index.js\n  create app/templates/index.hbs\ninstalling route-test\n  create tests/unit/routes/index-test.js  ProTip\u2122  If you ever need to know what generators are available, just type  ember help generate  and enjoy a deliciously long list of generating goodness.  This creates a few files for our index route and template file.  Looking at  app/routes/index.js  we see:  import Ember from 'ember';\n\nexport default Ember.Route.extend({\n});", 
            "title": "Create an index route"
        }, 
        {
            "location": "/blog-post/#update-an-index-template", 
            "text": "Let's take a look at the template file that was generated for us in  app/templates/index.hbs :  {{outlet}}  Just this funky thing called  {{outlet}} . Ember.js uses handlebars for templating, and the  outlet  variable is a special variable that Ember uses to say \"insert any subtemplates here\". If you've done anything with Ruby on Rails, think  yield  and you'll be awfully close. We're not adding any subtemplates to our  index  template so let's remove the  {{outlet}}  and add a sample post:  article \n   header class= page-header \n     h2 My Blog Post /h2 \n   /header \n   p This is a test post. /p  /article   Go look at the website in your browser again. Our 'My Blog Post' header should appear nicely beneath our big site header.", 
            "title": "Update an index template"
        }, 
        {
            "location": "/blog-post/#putting-our-posts-on-the-page", 
            "text": "So far we have only put some HTML on our page. Let's use the API to show our actual blog posts.  First let's add a  model  to our route in  app/routes/index.js . One of the jobs of routes is to provide a model to their template. Our model should be a list of blog posts retrieved from our API.  We could manually provide list of blog posts as our model:  import Ember from 'ember';\n\nexport default Ember.Route.extend({\n  model: function() {\n    return [{\n      title:  First post ,\n      body:  This is the post body. \n    }];\n  }\n});  Instead let's use the data store to retrieve all of our blog posts:  import Ember from 'ember';\n\nexport default Ember.Route.extend({\n  model: function() {\n    return this.store.findAll('blog-post');\n  }\n});  Now we should update our index template to loop over each of our blog posts and render it:  {{#each model as |post|}}\n   article \n     header class= page-header \n       h2 {{post.title}} /h2 \n     /header \n     p {{post.body}} /p \n   /article \n{{/each}}  The handlebars each helper allows us to enumerate over a list of items. This should print out all of our blog posts to the page. Let's check out our homepage in our browser again and make sure it worked.", 
            "title": "Putting our posts on the page"
        }, 
        {
            "location": "/blog-post/#additional-blog-post-routes", 
            "text": "What if we want to share a link to one of our blog posts?  To do that, we would need a page for each blog post.  Let's make those!", 
            "title": "Additional Blog post route(s)"
        }, 
        {
            "location": "/blog-post/#create-the-route", 
            "text": "Let's start by using a generator to make the new files we'll need:  $ ember generate route blog-post --path=/post/:blog_post_id\ninstalling route\n  create app/routes/blog-post.js\n  create app/templates/blog-post.hbs\nupdating router\n  add route blog-post\ninstalling route-test\n  create tests/unit/routes/blog-post-test.js  This creates a few files, and also adds some stuff to your   app/router.js :  import Ember from 'ember';\nimport config from './config/environment';\n\nconst Router = Ember.Router.extend({\n  location: config.locationType\n});\n\nRouter.map(function() {\n  this.route('blog-post', {\n    path: '/post/:blog_post_id'\n  });\n});\n\nexport default Router;  Here it has defined a route for us with a dynamic segment in the path,  :blog_post_id . This dynamic segment will be extracted from the URL and passed into the  model  hook on the  post  route. We can then use this parameter to look up that exact  blog-post  in the data store. So let's open up  app/routes/blog-post.js  that was generated for us and do just that.  import Ember from 'ember';\n\nexport default Ember.Route.extend({\n  model: function(params) {\n    return this.store.find('blog-post', params.blog_post_id);\n  }\n});", 
            "title": "Create the route"
        }, 
        {
            "location": "/blog-post/#update-the-template", 
            "text": "In order to make sure this is working, let's add some markup to  app/templates/blog-post.hbs  that will display a post. This file doesn't exist yet, so be sure to add it.  article \n   header class= page-header \n     h1 {{model.title}} /h1 \n   /header \n   p {{model.body}} /p  /article   Since we happen to know there is a blog post with  id: 1  on our API server, we can manually visit  http://localhost:4200/post/1  in our browser to test with an example blog post.", 
            "title": "Update the template"
        }, 
        {
            "location": "/blog-post/#the-magic-of-ember-data", 
            "text": "Ember-Data's REST Adapter comes with some freebies to save us time and unnecessary code. The adapter that we are using,  JSONAPIAdapter  is an extension of the REST Adapter, so we get to take advantage of this automagic if our application follows the URL conventions expected of the REST Adapter.  Based on our route's dynamic URL segments the REST Adapter will make the proper calls to the application's API for the model hook.  \n     \n         \n         \n         \n     \n   \n     \n       Action \n       HTTP Verb \n       URL \n     \n   \n   \n     \n       Find \n       GET \n       /post/:blog_post_id \n     \n     \n       Find All \n       GET \n       /post \n     \n     \n       Update \n       PUT \n       /post/:blog_post_id \n     \n     \n       Create \n       POST \n       /post \n     \n     \n       Delete \n       DELETE \n       /post/:blog_post_id \n     \n     ProTip\u2122  The store action determines the model name based on the defined dynamic segment. In our example  :blog_post_id  contains the proper snake-case name for our model with the suffix  _id  appended.  To confirm that this works,  delete the  app/routes/blog-post.js  file  and verify that our blog post page (http://localhost:4200/post/1) still works properly after reload.  Ember-CLI created a route test file automatically as well. To make sure your tests continue to pass, if you delete  app/routes/blog-post.js  you should also delete  tests/unit/routes/blog-post-test.js", 
            "title": "The magic of Ember-Data"
        }, 
        {
            "location": "/blog-post/#handlebars-link-to-helper", 
            "text": "Now that we have unique URLs for each blog post, we can link to these URLs from our index route.  To add these links open up the  app/templates/index.hbs  file and add a  link-to  Handlebars helper around our blog title:  {{#each model as |post|}}\n   article \n     header class= page-header \n       h2 \n        {{#link-to 'blog-post' post}} {{post.title}} {{/link-to}}\n       /h2 \n     /header \n     p {{post.body}} /p \n   /article \n{{/each}}  Now take a look at  http://localhost:4200  and title links should appear.  Click it!  And now you're at the page for our blog post.", 
            "title": "Handlebars link-to helper"
        }, 
        {
            "location": "/blog-post/#acceptance-testing", 
            "text": "With some user interaction added to our application we can now create an acceptance test. The user flow for this test will be:   Visit  /  Click the first blog link  Verify that the URL now matches  /post/:blog_post_id   First we will have to generate our acceptance test.  $ ember generate acceptance-test blog-post-show\ninstalling acceptance-test\n  create tests/acceptance/blog-post-show-test.js  Open the created file  tests/acceptance/blog-post-show-test.js  and see what is there:  import { test } from 'qunit';\nimport moduleForAcceptance from 'workshop/tests/helpers/module-for-acceptance';\n\nmoduleForAcceptance('Acceptance | blog post show');\n\ntest('visiting /blog-post-show', function(assert) {\n  visit('/blog-post-show');\n\n  andThen(function() {\n    assert.equal(currentURL(), '/blog-post-show');\n  });\n});  Let's first rename this test to something more applicable and remove the stuff inside.  test('visit blog post from index', function(assert) {\n\n});  There are a few helpers available to us that we will use  a lot  when writing acceptance tests.   visit(route) : Visits the given route  click(selector or element) : Clicks the element and triggers any actions triggered by that element's click event  andThen(callback) : Waits for any preceding promises to continue   Since  visit  and  click  are both asynchronous helpers we need to wrap subsequent logic in  andThen  to make sure actions complete before continuing onto the next step.  Now we will code out the steps listed above to test that we can link to a blog post from index.  test('visit blog post from index', function(assert) {\n  visit('/');\n  let blogSelector = 'article:first-of-type a';\n\n  andThen(function() {\n    click(blogSelector);\n  });\n\n  andThen(function() {\n    assert.equal(currentURL(), '/post/1');\n  });\n});  Verify the tests are passing by visiting  http://localhost:4200/tests  in the browser.", 
            "title": "Acceptance testing"
        }, 
        {
            "location": "/comments/", 
            "text": "Now that we have posts, are able to list them, and view individual posts we would like to add functionality to comment on blog posts.\n\n\nComments\n\n\nWe've seen how to use \nember generate model\n before to create our models. In this case, we want the comment to be a \nstring\n, and our Rails API defines the content of these comments as \ncontent\n.\n\n\n$ ember generate model comment content:string\ninstalling model\n  create app/models/comment.js\ninstalling model-test\n  create tests/unit/models/comment-test.js\n\n\n\n\nWe've seen this before.  Let's take a look at the model and see what it contains:\n\n\nimport Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  content: attr('string')\n});\n\n\n\n\nBut our comments need to be aware of our blog posts, and vice versa. We're going to add a one-to-many relationship which is built into Ember Data for us. In order to use it, we need to import the base ember-data module.\n\n\nThe comments need a \nbelongsTo\n since a comment belongs to a blog post:\n\n\nimport Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\nimport DS from 'ember-data';\n\nconst { belongsTo } = DS;\n\nexport default Model.extend({\n  content: attr('string'),\n  blogPost: belongsTo('blog-post')\n});\n\n\n\n\nWhereas the blog posts need a \nhasMany\n since a blog post has many comments:\n\n\nimport Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\nimport DS from 'ember-data';\n\nconst { hasMany } = DS;\n\nexport default Model.extend({\n  title: attr('string'),\n  body: attr('string'),\n  publishedDate: attr('date'),\n  comments: hasMany('comment')\n});\n\n\n\n\nEmber has a number of different ways to define relationships like this. You can \nlearn more here\n.\n\n\nTesting with dependencies\n\n\nRemember when we had only one model with no relationships to other models? Those are easy to unit test in isolation. At this point, unfortunately, your tests should be failing, because they can't find either the \ncomment\n dependency or \nblogPost\n dependency. When the tests need related models, you must tell Ember's test runner to load these dependencies.\n\n\nFind the following block in \ntests/unit/models/blog-post-test.js\n.\n\n\nmoduleForModel('blog-post', 'Unit | Model | blog post', {\n  // Specify the other units that are required for this test.\n  needs: []\n});\n\n\n\n\nYou must fill out the \nneeds\n property to tell Ember about the comment dependency:\n\n\n  needs: ['model:comment']\n\n\n\n\nFor the same block in \ntests/unit/models/comment-test.js\n, to tell Ember about the blog post dependency:\n\n\n  needs: ['model:blogPost']\n\n\n\n\nShow comments on a blog post\n\n\nLet's get comments to show up on a blog post by adding to our \napp/templates/blog-post.hbs\n:\n\n\narticle\n\n  \nheader class=\npage-header\n\n    \nh1\n{{model.title}}\n/h1\n\n  \n/header\n\n  \np\n{{model.body}}\n/p\n\n\n  \nh2\nComments\n/h2\n\n  \nul\n\n  {{#each model.comments as |comment|}}\n    \nli\n{{comment.content}}\n/li\n\n  {{/each}}\n  \n/ul\n\n\n/article\n\n\n\n\n\nWe first loop through all the \nmodel.comments\n with Ember's each syntax, defining \n|comment|\n as the local variable we use to access each \ncomment\n model. Inside of this loop, we output the comment content we defined in our model with \ncontent: attr('string')\n with \n{{comment.content}}\n.\n\n\nBut we also want a good user experience for our readers. They need to know when comments are being loaded and when there aren't any comments at all!\n\n\nFor the loading case, we have to think about sort of object our \nmodel.comments\n happens to be. It's a \nPromiseManyArray\n, and in our templates we can hook into the loading states made available by \nPromiseProxyMixin\n. The available states are:\n\n \nisPending\n\n\n \nisSettled\n\n\n \nisRejected\n\n\n \nisFulfilled\n\n\nWe can update our template to make use of this new property:\n\n\nh2\nComments\n/h2\n\n{{#if model.comments.isPending}}\n  \np\nLoading...\n/p\n\n{{else}}\n  \nul\n\n  ...\n  \n/ul\n\n{{/if}}\n\n\n\n\nNow our users know when comments are still loading and aren't presented with an ugly empty list of comments. If we wanted to go above and beyond, we could add a loading indicator here to indicate the comments are being loaded, but we'll move on.\n\n\nWe also want to handle the empty case. We can make use of Handlebars' if construct here:\n\n\nh2\nComments\n/h2\n\n{{#if model.comments.isPending}}\n  \np\nLoading...\n/p\n\n{{else}}\n  {{#if model.comments}}\n    \nul\n\n    {{#each model.comments as |comment|}}\n      \nli\n{{comment.content}}\n/li\n\n    {{/each}}\n    \n/ul\n\n  {{else}}\n    \np\nThere are no comments yet.\n/p\n\n  {{/if}}\n{{/if}}\n\n\n\n\nIf there are comments, we iterate over them. If there are none, we add a helpful message to the user to let them know there aren't any comments yet.\n\n\nSubmitting a comment\n\n\nWe can see existing comments on our blog but users have no way to submit comments yet, so let's make a form for users to submit comments.\n\n\nLet's make a commenting component to handle the form and submission for a new comment. To begin, we'll use a generator.\n\n\n$ ember generate component comment-form\ninstalling component\n  create app/components/comment-form.js\n  create app/templates/components/comment-form.hbs\ninstalling component-test\n  create tests/integration/components/comment-form-test.js\n\n\n\n\nLet's add this new component to our \nblog-post.hbs\n\n\nhr\n\n\n{{comment-form}}\n\n\n\n\nNow if we open up our \ncomment-form.hbs\n component template we can add in our form. When we open this up, we'll initially see a \n{{yeild}}\n statement. Components can either be rendered alone or can wrap in a block form. For our example we're going to keep it simple and render only the component. Replace the existing \n{{yield}}\n statement with the fllowing:\n\n\nform {{action 'saveComment' on='submit'}}\n\n  \ndiv class=\nform-group\n\n    {{textarea value=commentContent class='form-control' rows='3'}}\n  \n/div\n\n  \nbutton type=\nsubmit\n class=\nbtn btn-primary\nAdd My Comment!\n/button\n\n\n/form\n\n\n\n\n\nIf we visit the browser, we should see our comment form now on an individual post page. Though, it won't be wired up yet to work.\n\n\nComponent actions\n\n\nIn Ember-land you'll often hear the phrase \"data down, actions up\". This is applicable to components as well. We want to pass any data the component needs to render properly in when we call it, and any actions that the component needs to trigger will happen outside of the component.\n\n\nFor our comment form, we don't need to pass any data down but we will need to save the comment when the form submits. This is an action and should be handled outside of the component code, often in the \nroute\n.\n\n\nLet's create an action inside of our \nblog-post\n route. If you remember, we actually \ndeleted\n our blog-post route (and test) in the last section. We can add it back in again easily. The \ngenerate\n command will prompt us when it encounters already existing files, like our template for \nblog-post\n which we kept, so that we don't overwrite it.\n\n\n$ ember generate route blog-post\ninstalling route\n? Overwrite app/templates/blog-post.hbs? No, skip\n  create app/routes/blog-post.js\n  skip app/templates/blog-post.hbs\nupdating router\n  add route blog-post\ninstalling route-test\n  create tests/unit/routes/blog-post-test.js\n\n\n\n\nNow we can open up our \nblog-post\n route and add an action to handle the comment submission:\n\n\nimport Ember from 'ember';\n\nexport default Ember.Route.extend({\n  actions: {\n    saveComment(comment) {\n      let blogPost = this.controller.get('model');\n      this.store.createRecord('comment', {\n        blogPost: blogPost,\n        content: comment\n      }).save();\n    }\n  }\n});\n\n\n\n\nActions in Ember are handled in the \nactions: {}\n hash on an object. We're going to assume that our component will pass us the content of our comment to save. We can use \nstore.createRecord\n which takes the type of model as well as the hash to save and returns a promise.\n\n\nWe have to pass this action into our component when we create it so it knows what action to use on submission so let's add it back in our \nblog-post.hbs\n:\n\n\n{{comment-form saveComment='saveComment'}}\n\n\n\n\nWe're almost there! Now we just need to handle the action behavior inside the component. The component is still responsible for sending the action up. Let's open up our \ncomment-form.js\n and add this:\n\n\nimport Ember from 'ember';\n\nexport default Ember.Component.extend({\n  commentContent: '',\n\n  actions: {\n    saveComment() {\n      let comment = this.get('commentContent');\n      this.sendAction('saveComment', comment);\n      this.set('commentContent', '');\n    }\n  }\n});\n\n\n\n\nNow when we browse to an individual post we should be able to add a comment. Give it a try!", 
            "title": "Commenting"
        }, 
        {
            "location": "/comments/#comments", 
            "text": "We've seen how to use  ember generate model  before to create our models. In this case, we want the comment to be a  string , and our Rails API defines the content of these comments as  content .  $ ember generate model comment content:string\ninstalling model\n  create app/models/comment.js\ninstalling model-test\n  create tests/unit/models/comment-test.js  We've seen this before.  Let's take a look at the model and see what it contains:  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\n\nexport default Model.extend({\n  content: attr('string')\n});  But our comments need to be aware of our blog posts, and vice versa. We're going to add a one-to-many relationship which is built into Ember Data for us. In order to use it, we need to import the base ember-data module.  The comments need a  belongsTo  since a comment belongs to a blog post:  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\nimport DS from 'ember-data';\n\nconst { belongsTo } = DS;\n\nexport default Model.extend({\n  content: attr('string'),\n  blogPost: belongsTo('blog-post')\n});  Whereas the blog posts need a  hasMany  since a blog post has many comments:  import Model from 'ember-data/model';\nimport attr from 'ember-data/attr';\nimport DS from 'ember-data';\n\nconst { hasMany } = DS;\n\nexport default Model.extend({\n  title: attr('string'),\n  body: attr('string'),\n  publishedDate: attr('date'),\n  comments: hasMany('comment')\n});  Ember has a number of different ways to define relationships like this. You can  learn more here .", 
            "title": "Comments"
        }, 
        {
            "location": "/comments/#testing-with-dependencies", 
            "text": "Remember when we had only one model with no relationships to other models? Those are easy to unit test in isolation. At this point, unfortunately, your tests should be failing, because they can't find either the  comment  dependency or  blogPost  dependency. When the tests need related models, you must tell Ember's test runner to load these dependencies.  Find the following block in  tests/unit/models/blog-post-test.js .  moduleForModel('blog-post', 'Unit | Model | blog post', {\n  // Specify the other units that are required for this test.\n  needs: []\n});  You must fill out the  needs  property to tell Ember about the comment dependency:    needs: ['model:comment']  For the same block in  tests/unit/models/comment-test.js , to tell Ember about the blog post dependency:    needs: ['model:blogPost']", 
            "title": "Testing with dependencies"
        }, 
        {
            "location": "/comments/#show-comments-on-a-blog-post", 
            "text": "Let's get comments to show up on a blog post by adding to our  app/templates/blog-post.hbs :  article \n   header class= page-header \n     h1 {{model.title}} /h1 \n   /header \n   p {{model.body}} /p \n\n   h2 Comments /h2 \n   ul \n  {{#each model.comments as |comment|}}\n     li {{comment.content}} /li \n  {{/each}}\n   /ul  /article   We first loop through all the  model.comments  with Ember's each syntax, defining  |comment|  as the local variable we use to access each  comment  model. Inside of this loop, we output the comment content we defined in our model with  content: attr('string')  with  {{comment.content}} .  But we also want a good user experience for our readers. They need to know when comments are being loaded and when there aren't any comments at all!  For the loading case, we have to think about sort of object our  model.comments  happens to be. It's a  PromiseManyArray , and in our templates we can hook into the loading states made available by  PromiseProxyMixin . The available states are:   isPending    isSettled    isRejected    isFulfilled  We can update our template to make use of this new property:  h2 Comments /h2 \n{{#if model.comments.isPending}}\n   p Loading... /p \n{{else}}\n   ul \n  ...\n   /ul \n{{/if}}  Now our users know when comments are still loading and aren't presented with an ugly empty list of comments. If we wanted to go above and beyond, we could add a loading indicator here to indicate the comments are being loaded, but we'll move on.  We also want to handle the empty case. We can make use of Handlebars' if construct here:  h2 Comments /h2 \n{{#if model.comments.isPending}}\n   p Loading... /p \n{{else}}\n  {{#if model.comments}}\n     ul \n    {{#each model.comments as |comment|}}\n       li {{comment.content}} /li \n    {{/each}}\n     /ul \n  {{else}}\n     p There are no comments yet. /p \n  {{/if}}\n{{/if}}  If there are comments, we iterate over them. If there are none, we add a helpful message to the user to let them know there aren't any comments yet.", 
            "title": "Show comments on a blog post"
        }, 
        {
            "location": "/comments/#submitting-a-comment", 
            "text": "We can see existing comments on our blog but users have no way to submit comments yet, so let's make a form for users to submit comments.  Let's make a commenting component to handle the form and submission for a new comment. To begin, we'll use a generator.  $ ember generate component comment-form\ninstalling component\n  create app/components/comment-form.js\n  create app/templates/components/comment-form.hbs\ninstalling component-test\n  create tests/integration/components/comment-form-test.js  Let's add this new component to our  blog-post.hbs  hr \n\n{{comment-form}}  Now if we open up our  comment-form.hbs  component template we can add in our form. When we open this up, we'll initially see a  {{yeild}}  statement. Components can either be rendered alone or can wrap in a block form. For our example we're going to keep it simple and render only the component. Replace the existing  {{yield}}  statement with the fllowing:  form {{action 'saveComment' on='submit'}} \n   div class= form-group \n    {{textarea value=commentContent class='form-control' rows='3'}}\n   /div \n   button type= submit  class= btn btn-primary Add My Comment! /button  /form   If we visit the browser, we should see our comment form now on an individual post page. Though, it won't be wired up yet to work.", 
            "title": "Submitting a comment"
        }, 
        {
            "location": "/comments/#component-actions", 
            "text": "In Ember-land you'll often hear the phrase \"data down, actions up\". This is applicable to components as well. We want to pass any data the component needs to render properly in when we call it, and any actions that the component needs to trigger will happen outside of the component.  For our comment form, we don't need to pass any data down but we will need to save the comment when the form submits. This is an action and should be handled outside of the component code, often in the  route .  Let's create an action inside of our  blog-post  route. If you remember, we actually  deleted  our blog-post route (and test) in the last section. We can add it back in again easily. The  generate  command will prompt us when it encounters already existing files, like our template for  blog-post  which we kept, so that we don't overwrite it.  $ ember generate route blog-post\ninstalling route\n? Overwrite app/templates/blog-post.hbs? No, skip\n  create app/routes/blog-post.js\n  skip app/templates/blog-post.hbs\nupdating router\n  add route blog-post\ninstalling route-test\n  create tests/unit/routes/blog-post-test.js  Now we can open up our  blog-post  route and add an action to handle the comment submission:  import Ember from 'ember';\n\nexport default Ember.Route.extend({\n  actions: {\n    saveComment(comment) {\n      let blogPost = this.controller.get('model');\n      this.store.createRecord('comment', {\n        blogPost: blogPost,\n        content: comment\n      }).save();\n    }\n  }\n});  Actions in Ember are handled in the  actions: {}  hash on an object. We're going to assume that our component will pass us the content of our comment to save. We can use  store.createRecord  which takes the type of model as well as the hash to save and returns a promise.  We have to pass this action into our component when we create it so it knows what action to use on submission so let's add it back in our  blog-post.hbs :  {{comment-form saveComment='saveComment'}}  We're almost there! Now we just need to handle the action behavior inside the component. The component is still responsible for sending the action up. Let's open up our  comment-form.js  and add this:  import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  commentContent: '',\n\n  actions: {\n    saveComment() {\n      let comment = this.get('commentContent');\n      this.sendAction('saveComment', comment);\n      this.set('commentContent', '');\n    }\n  }\n});  Now when we browse to an individual post we should be able to add a comment. Give it a try!", 
            "title": "Component actions"
        }, 
        {
            "location": "/next/", 
            "text": "Feedback\n\n\nhttps://hbrysiewicz.typeform.com/to/DMKtHS\n\n\nPlease take 2 minutes to complete our breif workshop feedback form!\n\n\nWhere do I go next?\n\n\nThere are many great resources available to continue your learning with Ember. The book \nRock n' Roll with Ember.js\n by Balinti Erdi is a book that slowly introduces concepts and best practices as you build an Ember application. It crushes the perceived learning curve of Ember and helps to overcome that initial frustration, and help you grok Ember a lot faster, by pinpointing the core concepts and explaining them in detail.\n\n\nThe Ember guides are great for diving deep once you understand the fundamentals. They're also versioned so you can be sure you're looking at accurate information for whatever version you happen to be working with.\n\n\nThanks to everyone who helped out\n\n\nEchobind - Sponsors\n\n\nInstructors\n\n\nMichael Yared\n\n\nHeather Brysiewicz\n\n\nJosh Smith\n\n\nXavier Lange\n\n\nTrey Hunner\n\n\nScott Newcomer\n\n\nDrew Purdy\n\n\nBenjamin Rhodes\n\n\nMatt Schick", 
            "title": "What's Next & Thanks"
        }, 
        {
            "location": "/next/#feedback", 
            "text": "https://hbrysiewicz.typeform.com/to/DMKtHS  Please take 2 minutes to complete our breif workshop feedback form!", 
            "title": "Feedback"
        }, 
        {
            "location": "/next/#where-do-i-go-next", 
            "text": "There are many great resources available to continue your learning with Ember. The book  Rock n' Roll with Ember.js  by Balinti Erdi is a book that slowly introduces concepts and best practices as you build an Ember application. It crushes the perceived learning curve of Ember and helps to overcome that initial frustration, and help you grok Ember a lot faster, by pinpointing the core concepts and explaining them in detail.  The Ember guides are great for diving deep once you understand the fundamentals. They're also versioned so you can be sure you're looking at accurate information for whatever version you happen to be working with.", 
            "title": "Where do I go next?"
        }, 
        {
            "location": "/next/#thanks-to-everyone-who-helped-out", 
            "text": "", 
            "title": "Thanks to everyone who helped out"
        }, 
        {
            "location": "/next/#echobind-sponsors", 
            "text": "", 
            "title": "Echobind - Sponsors"
        }, 
        {
            "location": "/next/#instructors", 
            "text": "", 
            "title": "Instructors"
        }, 
        {
            "location": "/next/#michael-yared", 
            "text": "", 
            "title": "Michael Yared"
        }, 
        {
            "location": "/next/#heather-brysiewicz", 
            "text": "", 
            "title": "Heather Brysiewicz"
        }, 
        {
            "location": "/next/#josh-smith", 
            "text": "", 
            "title": "Josh Smith"
        }, 
        {
            "location": "/next/#xavier-lange", 
            "text": "", 
            "title": "Xavier Lange"
        }, 
        {
            "location": "/next/#trey-hunner", 
            "text": "", 
            "title": "Trey Hunner"
        }, 
        {
            "location": "/next/#scott-newcomer", 
            "text": "", 
            "title": "Scott Newcomer"
        }, 
        {
            "location": "/next/#drew-purdy", 
            "text": "", 
            "title": "Drew Purdy"
        }, 
        {
            "location": "/next/#benjamin-rhodes", 
            "text": "", 
            "title": "Benjamin Rhodes"
        }, 
        {
            "location": "/next/#matt-schick", 
            "text": "", 
            "title": "Matt Schick"
        }
    ]
}